# RateLimiter

### 基于Redis的分布式令牌桶算法

`origin.limiter`基于Guava改进的分布式令牌桶算法，使用Redis存储信息，分析见[基于 redis 的分布式令牌桶算法](http://3ms.huawei.com/km/groups/1003945/blogs/details/10410143?l=zh-cn) 。

算法大体流程参考了Guava的`SmoothBursty`令牌桶算法， 通过其可透支令牌的特性，实现请求缓冲队列的功能，即令牌桶在令牌不足时，如果透支的令牌恢复时间不超过设定的超时时间，则允许透支令牌，并使请求休眠到当次申请的令牌恢复再放行。

使用了jedis连接并读写Redis，分布式Redis锁用了Redission。实际移植到微服务中时，Redis的读写换成了redisTemplate，而分布式Redis锁则采用了Itrdk中的实现，测试效果等同于jedis和Redission。

另外移植到gw-air之后做了代码清理和细节优化，移植到微服务中可以gw-air的[f_rate_limiter](https://codehub-g.huawei.com/smartcom/itravel/traffic/gw-air/files?ref=f_rate_limiter) 分支为准。

### 存在的问题

冷启动问题：当桶内令牌数较多(尤其是满令牌时)，对于突发请求会出现实际一秒内发出的令牌数量多于期望的情况。
例如：创建一个限流器，每秒发送5个令牌，桶的大小也设置为5，等待令牌桶装满5个令牌，假设每个请求申请一个令牌，在极短的时间内先来了5个请求，此时令牌桶中的5个令牌会全部发出去，假设处理折5个请求花了50ms，则1秒中还剩下950ms，这段时间最多还能生成4个令牌，因此这1秒中最多能发出去9个令牌。
在实际测试的情况下，连接远程的redis，并且代码运行速度稍微慢一些的话，就会出现这种情况。比如在令牌桶满令牌的情况下来了10个请求，光是把桶里的5个令牌发出去就会花费超过200ms，此时已经新生成了一个令牌，假设超时时间还允许透支3个令牌，则一秒内实际发出了5+1+3=9个令牌。

对于这种情况，有两种解决方法：
1. 减小令牌桶的容量，令牌生成的速度不变
2. 改进令牌桶算法，参考Guava的`SmoothWarmingUp`实现，增加从桶里拿走已经生成的令牌的代价。